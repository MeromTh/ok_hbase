#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require_relative 'hbase.thrift_types.rb'

module Apache
  module Hadoop
    module Hbase
      module Thrift2
        module THBaseService
          class Client
            include ::Thrift::Client

            def exists(table, get)
              send_exists(table, get)
              return recv_exists()
            end

            def send_exists(table, get)
              send_message('exists', Exists_args, :table => table, :get => get)
            end

            def recv_exists()
              result = receive_message(Exists_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'exists failed: unknown result')
            end

            def get(table, get)
              send_get(table, get)
              return recv_get()
            end

            def send_get(table, get)
              send_message('get', Get_args, :table => table, :get => get)
            end

            def recv_get()
              result = receive_message(Get_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get failed: unknown result')
            end

            def getMultiple(table, gets)
              send_getMultiple(table, gets)
              return recv_getMultiple()
            end

            def send_getMultiple(table, gets)
              send_message('getMultiple', GetMultiple_args, :table => table, :gets => gets)
            end

            def recv_getMultiple()
              result = receive_message(GetMultiple_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getMultiple failed: unknown result')
            end

            def put(table, put)
              send_put(table, put)
              recv_put()
            end

            def send_put(table, put)
              send_message('put', Put_args, :table => table, :put => put)
            end

            def recv_put()
              result = receive_message(Put_result)
              raise result.io unless result.io.nil?
              return
            end

            def checkAndPut(table, row, family, qualifier, value, put)
              send_checkAndPut(table, row, family, qualifier, value, put)
              return recv_checkAndPut()
            end

            def send_checkAndPut(table, row, family, qualifier, value, put)
              send_message('checkAndPut', CheckAndPut_args, :table => table, :row => row, :family => family, :qualifier => qualifier, :value => value, :put => put)
            end

            def recv_checkAndPut()
              result = receive_message(CheckAndPut_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'checkAndPut failed: unknown result')
            end

            def putMultiple(table, puts)
              send_putMultiple(table, puts)
              recv_putMultiple()
            end

            def send_putMultiple(table, puts)
              send_message('putMultiple', PutMultiple_args, :table => table, :puts => puts)
            end

            def recv_putMultiple()
              result = receive_message(PutMultiple_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteSingle(table, deleteSingle)
              send_deleteSingle(table, deleteSingle)
              recv_deleteSingle()
            end

            def send_deleteSingle(table, deleteSingle)
              send_message('deleteSingle', DeleteSingle_args, :table => table, :deleteSingle => deleteSingle)
            end

            def recv_deleteSingle()
              result = receive_message(DeleteSingle_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteMultiple(table, deletes)
              send_deleteMultiple(table, deletes)
              return recv_deleteMultiple()
            end

            def send_deleteMultiple(table, deletes)
              send_message('deleteMultiple', DeleteMultiple_args, :table => table, :deletes => deletes)
            end

            def recv_deleteMultiple()
              result = receive_message(DeleteMultiple_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'deleteMultiple failed: unknown result')
            end

            def checkAndDelete(table, row, family, qualifier, value, deleteSingle)
              send_checkAndDelete(table, row, family, qualifier, value, deleteSingle)
              return recv_checkAndDelete()
            end

            def send_checkAndDelete(table, row, family, qualifier, value, deleteSingle)
              send_message('checkAndDelete', CheckAndDelete_args, :table => table, :row => row, :family => family, :qualifier => qualifier, :value => value, :deleteSingle => deleteSingle)
            end

            def recv_checkAndDelete()
              result = receive_message(CheckAndDelete_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'checkAndDelete failed: unknown result')
            end

            def increment(table, increment)
              send_increment(table, increment)
              return recv_increment()
            end

            def send_increment(table, increment)
              send_message('increment', Increment_args, :table => table, :increment => increment)
            end

            def recv_increment()
              result = receive_message(Increment_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'increment failed: unknown result')
            end

            def openScanner(table, scan)
              send_openScanner(table, scan)
              return recv_openScanner()
            end

            def send_openScanner(table, scan)
              send_message('openScanner', OpenScanner_args, :table => table, :scan => scan)
            end

            def recv_openScanner()
              result = receive_message(OpenScanner_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'openScanner failed: unknown result')
            end

            def getScannerRows(scannerId, numRows)
              send_getScannerRows(scannerId, numRows)
              return recv_getScannerRows()
            end

            def send_getScannerRows(scannerId, numRows)
              send_message('getScannerRows', GetScannerRows_args, :scannerId => scannerId, :numRows => numRows)
            end

            def recv_getScannerRows()
              result = receive_message(GetScannerRows_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getScannerRows failed: unknown result')
            end

            def closeScanner(scannerId)
              send_closeScanner(scannerId)
              recv_closeScanner()
            end

            def send_closeScanner(scannerId)
              send_message('closeScanner', CloseScanner_args, :scannerId => scannerId)
            end

            def recv_closeScanner()
              result = receive_message(CloseScanner_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

          end

          class Processor
            include ::Thrift::Processor

            def process_exists(seqid, iprot, oprot)
              args = read_args(iprot, Exists_args)
              result = Exists_result.new()
              begin
                result.success = @handler.exists(args.table, args.get)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'exists', seqid)
            end

            def process_get(seqid, iprot, oprot)
              args = read_args(iprot, Get_args)
              result = Get_result.new()
              begin
                result.success = @handler.get(args.table, args.get)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'get', seqid)
            end

            def process_getMultiple(seqid, iprot, oprot)
              args = read_args(iprot, GetMultiple_args)
              result = GetMultiple_result.new()
              begin
                result.success = @handler.getMultiple(args.table, args.gets)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'getMultiple', seqid)
            end

            def process_put(seqid, iprot, oprot)
              args = read_args(iprot, Put_args)
              result = Put_result.new()
              begin
                @handler.put(args.table, args.put)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'put', seqid)
            end

            def process_checkAndPut(seqid, iprot, oprot)
              args = read_args(iprot, CheckAndPut_args)
              result = CheckAndPut_result.new()
              begin
                result.success = @handler.checkAndPut(args.table, args.row, args.family, args.qualifier, args.value, args.put)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'checkAndPut', seqid)
            end

            def process_putMultiple(seqid, iprot, oprot)
              args = read_args(iprot, PutMultiple_args)
              result = PutMultiple_result.new()
              begin
                @handler.putMultiple(args.table, args.puts)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'putMultiple', seqid)
            end

            def process_deleteSingle(seqid, iprot, oprot)
              args = read_args(iprot, DeleteSingle_args)
              result = DeleteSingle_result.new()
              begin
                @handler.deleteSingle(args.table, args.deleteSingle)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteSingle', seqid)
            end

            def process_deleteMultiple(seqid, iprot, oprot)
              args = read_args(iprot, DeleteMultiple_args)
              result = DeleteMultiple_result.new()
              begin
                result.success = @handler.deleteMultiple(args.table, args.deletes)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteMultiple', seqid)
            end

            def process_checkAndDelete(seqid, iprot, oprot)
              args = read_args(iprot, CheckAndDelete_args)
              result = CheckAndDelete_result.new()
              begin
                result.success = @handler.checkAndDelete(args.table, args.row, args.family, args.qualifier, args.value, args.deleteSingle)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'checkAndDelete', seqid)
            end

            def process_increment(seqid, iprot, oprot)
              args = read_args(iprot, Increment_args)
              result = Increment_result.new()
              begin
                result.success = @handler.increment(args.table, args.increment)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'increment', seqid)
            end

            def process_openScanner(seqid, iprot, oprot)
              args = read_args(iprot, OpenScanner_args)
              result = OpenScanner_result.new()
              begin
                result.success = @handler.openScanner(args.table, args.scan)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'openScanner', seqid)
            end

            def process_getScannerRows(seqid, iprot, oprot)
              args = read_args(iprot, GetScannerRows_args)
              result = GetScannerRows_result.new()
              begin
                result.success = @handler.getScannerRows(args.scannerId, args.numRows)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'getScannerRows', seqid)
            end

            def process_closeScanner(seqid, iprot, oprot)
              args = read_args(iprot, CloseScanner_args)
              result = CloseScanner_result.new()
              begin
                @handler.closeScanner(args.scannerId)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'closeScanner', seqid)
            end

          end

          # HELPER FUNCTIONS AND STRUCTURES

          class Exists_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            GET = 2

            FIELDS = {
              # the table to check on
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TGet to check for
              GET => {:type => ::Thrift::Types::STRUCT, :name => 'get', :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field get is unset!') unless @get
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Exists_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            GET = 2

            FIELDS = {
              # the table to get from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TGet to fetch
              GET => {:type => ::Thrift::Types::STRUCT, :name => 'get', :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field get is unset!') unless @get
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::TResult},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            GETS = 2

            FIELDS = {
              # the table to get from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # a list of TGets to fetch, the Result list
# will have the Results at corresponding positions
# or null if there was an error
              GETS => {:type => ::Thrift::Types::LIST, :name => 'gets', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field gets is unset!') unless @gets
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Put_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            PUT = 2

            FIELDS = {
              # the table to put data in
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TPut to put
              PUT => {:type => ::Thrift::Types::STRUCT, :name => 'put', :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field put is unset!') unless @put
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Put_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndPut_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            ROW = 2
            FAMILY = 3
            QUALIFIER = 4
            VALUE = 5
            PUT = 6

            FIELDS = {
              # to check in and put to
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # row to check
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column family to check
              FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family', :binary => true},
              # column qualifier to check
              QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'qualifier', :binary => true},
              # the expected value, if not provided the
# check is for the non-existence of the
# column in question
              VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true},
              # the TPut to put if the check succeeds
              PUT => {:type => ::Thrift::Types::STRUCT, :name => 'put', :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field family is unset!') unless @family
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field qualifier is unset!') unless @qualifier
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field put is unset!') unless @put
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndPut_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class PutMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            PUTS = 2

            FIELDS = {
              # the table to put data in
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # a list of TPuts to commit
              PUTS => {:type => ::Thrift::Types::LIST, :name => 'puts', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field puts is unset!') unless @puts
            end

            ::Thrift::Struct.generate_accessors self
          end

          class PutMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteSingle_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            DELETESINGLE = 2

            FIELDS = {
              # the table to delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TDelete to delete
              DELETESINGLE => {:type => ::Thrift::Types::STRUCT, :name => 'deleteSingle', :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field deleteSingle is unset!') unless @deleteSingle
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteSingle_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            DELETES = 2

            FIELDS = {
              # the table to delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # list of TDeletes to delete
              DELETES => {:type => ::Thrift::Types::LIST, :name => 'deletes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field deletes is unset!') unless @deletes
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndDelete_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            ROW = 2
            FAMILY = 3
            QUALIFIER = 4
            VALUE = 5
            DELETESINGLE = 6

            FIELDS = {
              # to check in and delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # row to check
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column family to check
              FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family', :binary => true},
              # column qualifier to check
              QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'qualifier', :binary => true},
              # the expected value, if not provided the
# check is for the non-existence of the
# column in question
              VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true},
              # the TDelete to execute if the check succeeds
              DELETESINGLE => {:type => ::Thrift::Types::STRUCT, :name => 'deleteSingle', :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field family is unset!') unless @family
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field qualifier is unset!') unless @qualifier
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field deleteSingle is unset!') unless @deleteSingle
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndDelete_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            INCREMENT = 2

            FIELDS = {
              # the table to increment the value on
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TIncrement to increment
              INCREMENT => {:type => ::Thrift::Types::STRUCT, :name => 'increment', :class => ::Apache::Hadoop::Hbase::Thrift2::TIncrement}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field increment is unset!') unless @increment
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::TResult},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class OpenScanner_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            SCAN = 2

            FIELDS = {
              # the table to get the Scanner for
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the scan object to get a Scanner for
              SCAN => {:type => ::Thrift::Types::STRUCT, :name => 'scan', :class => ::Apache::Hadoop::Hbase::Thrift2::TScan}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scan is unset!') unless @scan
            end

            ::Thrift::Struct.generate_accessors self
          end

          class OpenScanner_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerRows_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SCANNERID = 1
            NUMROWS = 2

            FIELDS = {
              # the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
              SCANNERID => {:type => ::Thrift::Types::I32, :name => 'scannerId'},
              # number of rows to return
              NUMROWS => {:type => ::Thrift::Types::I32, :name => 'numRows', :default => 1}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scannerId is unset!') unless @scannerId
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerRows_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1
            IA = 2

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError},
              # if the scannerId is invalid
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CloseScanner_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SCANNERID = 1

            FIELDS = {
              # the Id of the Scanner to close *
              SCANNERID => {:type => ::Thrift::Types::I32, :name => 'scannerId'}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scannerId is unset!') unless @scannerId
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CloseScanner_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError},
              # if the scannerId is invalid
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

        end

      end
    end
  end
end
